<template>
  <ion-card>
    <ion-card-header>
      <div>
        <ion-card-subtitle class="overline">{{ rule.ruleId }}</ion-card-subtitle>
        <ion-card-title>{{ rule.ruleName }}</ion-card-title>
        <ion-card-subtitle>{{ ruleIndex+1 }}/{{ total }}</ion-card-subtitle>
      </div>
      <div>
        <ion-button fill="clear" color="medium" class="ion-no-padding" :disabled="ruleIndex === 0" @click="updateRuleOrder('prev')">
          <ion-icon :icon="chevronUpOutline" slot="icon-only" />
        </ion-button>
        <ion-button fill="clear" color="medium" class="ion-no-padding" :disabled="ruleIndex === rules.length - 1" @click="updateRuleOrder('next')">
          <ion-icon :icon="chevronDownOutline" slot="icon-only" />
        </ion-button>
      </div>
    </ion-card-header>

    <ion-item lines="full" v-if="selectedPage.path === '/threshold'">
      <ion-icon slot="start" :icon="globeOutline"/>
      <ion-label class="ion-text-wrap">{{ translate(selectedPage.name) }}</ion-label>
      <ion-chip slot="end" outline @click="editThreshold()">{{ rule.ruleActions?.length ? rule.ruleActions[0]?.fieldValue : '-' }}</ion-chip>
    </ion-item>
    <ion-item lines="full" v-else-if="selectedPage.path === '/safety-stock'">
      <ion-icon slot="start" :icon="pulseOutline"/>
      <ion-label class="ion-text-wrap">{{ translate(selectedPage.name) }}</ion-label>
      <ion-chip slot="end" outline @click="editSafetyStock()">{{ rule.ruleActions?.length ? rule.ruleActions[0].fieldValue : '-' }}</ion-chip>
    </ion-item>
    <ion-item lines="full" v-else-if="selectedPage.path === '/store-pickup'">
      <ion-icon slot="start" :icon="storefrontOutline"/>
      <ion-toggle :checked="props.rule.ruleActions ? props.rule.ruleActions[0].fieldValue : false" @click.prevent="updateRulePickup($event)">{{ translate(selectedPage.name) }}</ion-toggle>
    </ion-item>
    <ion-item lines="full" v-else-if="selectedPage.path === '/shipping'">
      <ion-icon slot="start" :icon="sendOutline"/>
      <ion-toggle :checked="props.rule.ruleActions ? props.rule.ruleActions[0].fieldValue : false" @click.prevent="updateRuleShipping($event)">{{ translate(selectedPage.name) }}</ion-toggle>
    </ion-item>

    <ion-list>
      <template v-if="selectedPage.path === '/threshold' || selectedSegment === 'RG_PICKUP_CHANNEL' || selectedSegment === 'RG_SHIPPING_CHANNEL'">
        <ion-item-divider color="light">
          <ion-label>{{ translate("Channels") }}</ion-label>
          <ion-button slot="end" fill="clear" color="medium" @click="openSelectConfigFacilitiesModal()">
            <ion-icon :icon="optionsOutline" slot="icon-only" />
          </ion-button>
        </ion-item-divider>

        <ion-item v-if="isRuleConditionAvailable('ENTCT_ATP_FACILITIES')" lines="none">
          <ion-icon slot="start" :icon="checkmarkDoneCircleOutline"/>
          <ion-label class="ion-text-wrap">{{ getRuleConditions("ENTCT_ATP_FACILITIES") }}</ion-label>
        </ion-item>
      </template>
      
      <template v-else>
        <ion-item-divider color="light">
          <ion-label>{{ translate("Facility groups") }}</ion-label>
          <ion-button slot="end" fill="clear" color="medium" @click="openUpdateFacilityGroupModal()">
            <ion-icon :icon="optionsOutline" slot="icon-only" />
          </ion-button>
        </ion-item-divider>
        
        <ion-item v-if="isRuleConditionAvailable('ENTCT_ATP_FAC_GROUPS', 'facilityGroups', 'in')">
          <ion-icon slot="start" :icon="checkmarkDoneCircleOutline"/>
          <ion-label class="ion-text-wrap">{{ getRuleConditions("ENTCT_ATP_FAC_GROUPS", "facilityGroups", "in") }}</ion-label>
        </ion-item>
        <ion-item lines="none" v-if="isRuleConditionAvailable('ENTCT_ATP_FAC_GROUPS', 'facilityGroups', 'not-in')">
          <ion-icon slot="start" :icon="closeCircleOutline"/>
          <ion-label class="ion-text-wrap">{{ getRuleConditions("ENTCT_ATP_FAC_GROUPS", "facilityGroups", "not-in") }}</ion-label>
        </ion-item>
      </template>

      <ion-item-divider color="light">
        <ion-label>{{ translate("Product tags") }}</ion-label>
        <ion-button slot="end" fill="clear" color="medium" @click="openUpdateProductFiltersModal('tags', 'tagsFacet', 'tags')">
          <ion-icon :icon="optionsOutline" slot="icon-only" />
        </ion-button>
      </ion-item-divider>

      <ion-item v-if="isRuleConditionAvailable('ENTCT_ATP_FILTER', 'tags', 'in')">
        <ion-icon slot="start" :icon="checkmarkDoneCircleOutline"/>
        <ion-label class="ion-text-wrap">{{ getRuleConditions("ENTCT_ATP_FILTER", "tags", "in") }}</ion-label>
      </ion-item>
      <ion-item lines="none" v-if="isRuleConditionAvailable('ENTCT_ATP_FILTER', 'tags', 'not-in')">
        <ion-icon slot="start" :icon="closeCircleOutline"/>
        <ion-label class="ion-text-wrap">{{ getRuleConditions("ENTCT_ATP_FILTER", "tags", "not-in") }}</ion-label>
      </ion-item>

      <ion-item-divider color="light">
        <ion-label>{{ translate("Product features") }}</ion-label>
        <ion-button slot="end" fill="clear" color="medium"  @click="openUpdateProductFiltersModal('product features', 'productFeaturesFacet', 'productFeatures')">
          <ion-icon :icon="optionsOutline" slot="icon-only" />
        </ion-button>
      </ion-item-divider>

      <ion-item v-if="isRuleConditionAvailable('ENTCT_ATP_FILTER', 'productFeatures', 'in')">
        <ion-icon slot="start" :icon="checkmarkDoneCircleOutline"/>
        <ion-label class="ion-text-wrap">{{ getRuleConditions("ENTCT_ATP_FILTER", "productFeatures", "in") }}</ion-label>
      </ion-item>
      <ion-item lines="full" v-if="isRuleConditionAvailable('ENTCT_ATP_FILTER', 'productFeatures', 'not-in')">
        <ion-icon slot="start" :icon="closeCircleOutline"/>
        <ion-label class="ion-text-wrap">{{ getRuleConditions("ENTCT_ATP_FILTER", "productFeatures", "not-in") }}</ion-label>
      </ion-item>

      <ion-item lines="none">
        <ion-button @click="editRuleName()" fill="clear">{{ translate("Edit name") }}</ion-button>
        <ion-button @click="archiveRule()" color="medium" fill="clear" slot="end">
          <ion-icon :icon="archiveOutline" slot="icon-only"/>
        </ion-button>
      </ion-item>
    </ion-list>
  </ion-card>
</template>

<script setup lang="ts">
import { IonButton, IonCard, IonCardHeader, IonCardSubtitle, IonCardTitle, IonChip, IonIcon, IonItem, IonItemDivider, IonLabel, IonList, IonToggle, alertController, modalController } from '@ionic/vue';
import { computed, defineProps, onMounted, ref } from 'vue';
import { archiveOutline, checkmarkDoneCircleOutline, chevronDownOutline, chevronUpOutline, closeCircleOutline, globeOutline, optionsOutline, pulseOutline, sendOutline, storefrontOutline } from 'ionicons/icons';
import { useRouter } from 'vue-router';
import { translate } from '@hotwax/dxp-components';
import { RuleService } from '@/services/RuleService';
import { useStore } from 'vuex';
import { showToast } from '@/utils';
import logger from '@/logger';
import SelectConfigFacilitiesModal from '@/components/SelectConfigFacilitiesModal.vue';
import UpdateProductFiltersModal from '@/components/UpdateProductFiltersModal.vue';
import UpdateFacilityGroupModal from '@/components/UpdateFacilityGroupModal.vue';
import emitter from '@/event-bus';

const router = useRouter();
const store = useStore();

const props = defineProps(["selectedSegment", "rule", "ruleIndex"])
const total = computed(() => store.getters["rule/getTotalRulesCount"])
const configFacilities = computed(() => store.getters["util/getConfigFacilities"])
const facilityGroups = computed(() => store.getters["util/getFacilityGroups"])
const rules = computed(() => store.getters["rule/getRules"]);

const selectedPage = ref({
  path: '',
  name: ''
}) as any;

onMounted(() => {
  selectedPage.value.path = router.currentRoute.value.path
  selectedPage.value.name = router.currentRoute.value.name
})

async function editThreshold() {
  const alert = await alertController.create({
    header: translate("Edit threshold"),
    inputs: [{
      name: "threshold",
      placeholder: translate("Threshold"),
      type: "number",
      value: props.rule.ruleActions?.length ? props.rule.ruleActions[0].fieldValue : 0,
      min: 0
    }],
    buttons: [{
      text: translate('Cancel'),
      role: "cancel"
    },
    {
      text: translate('Update'),
      handler: async(data) => {
        if(!data.threshold || data.threshold < 0) {
          showToast(translate("Threshold should be greater than or equal to 0."));
          return false;
        }

        emitter.emit("presentLoader");

        const rule = JSON.parse(JSON.stringify(props.rule))

        if(!rule.ruleActions?.length) {
          rule.ruleActions = [{
            "ruleId": props.rule.ruleId,
            "actionTypeEnumId": "ATP_SAFETY_STOCK",
            "fieldName": "facility-safety-stock",
            "fieldValue": data.threshold
          }]
        } else {
          rule.ruleActions[0].fieldValue = data.threshold
        }

        try {
          await RuleService.updateRule(rule, props.rule.ruleId)
          await store.dispatch('rule/updateRuleData', { rule })
          showToast(translate("Threshold updated successfully."))
          alertController.dismiss()
        } catch(err: any) {
          showToast(translate("Failed to update threshold."))
          logger.error(err);
        }
        emitter.emit("dismissLoader");
      }
    }]
  })

  await alert.present()
}

async function editSafetyStock() {
  const alert = await alertController.create({
    header: translate("Edit safety stock"),
    inputs: [{
      name: "safetyStock",
      placeholder: translate("Safety stock"),
      type: "number",
      value: props.rule.ruleActions?.length ? props.rule.ruleActions[0].fieldValue : 0,
      min: 0
    }],
    buttons: [{
      text: translate('Cancel'),
      role: "cancel"
    },
    {
      text: translate('Update'),
      handler: async (data: any) => {
        if(!data.safetyStock || data.safetyStock < 0) {
          showToast(translate("Safety stock should be greater than or equal to 0."));
          return false;
        }

        emitter.emit("presentLoader");

        const rule = JSON.parse(JSON.stringify(props.rule))

        if(!rule.ruleActions?.length) {
          rule.ruleActions = [{
            "ruleId": props.rule.ruleId,
            "actionTypeEnumId": "ATP_SAFETY_STOCK",
            "fieldName": "facility-safety-stock",
            "fieldValue": data.safetyStock
          }]
        } else {
          rule.ruleActions[0].fieldValue = data.safetyStock
        }

        try {
          await RuleService.updateRule(rule, props.rule.ruleId)
          await store.dispatch('rule/updateRuleData', { rule })
          showToast(translate("Safety stock updated successfully."))
          alertController.dismiss()
        } catch(err: any) {
          showToast(translate("Failed to update safety stock."))
          logger.error(err);
        }
        emitter.emit("dismissLoader");
      }
    }]
  })

  await alert.present()
}

async function editRuleName() {
  const alert = await alertController.create({
    header: translate("Edit name"),
    inputs: [{
      name: "name",
      placeholder: translate("Name"),
      type: "text",
      value: props.rule.ruleName
    }],
    buttons: [{
      text: translate('Cancel'),
      role: "cancel"
    },
    {
      text: translate('Update'),
      handler: async(data) => {
        if(data.name) {
          emitter.emit("presentLoader");
          const rule = JSON.parse(JSON.stringify(props.rule))
          rule.ruleName = data.name

          try {
            await RuleService.updateRule(rule, props.rule.ruleId)
            showToast(translate("Rule name updated successfully."))
            await store.dispatch('rule/updateRuleData', { rule })
            alertController.dismiss()
          } catch(err: any) {
            logger.error(err)
            showToast(translate("Failed to update rule name."))
          }
          emitter.emit("dismissLoader");
        }
      }
    }]
  })

  await alert.present()
}

function getRuleConditions(conditionTypeEnumId: string, fieldName?: string, operator? : string) {
  if(!props.rule.ruleConditions) return;

  if(fieldName && operator) {
    const condition = props.rule.ruleConditions.find((condition: any) => condition.conditionTypeEnumId === conditionTypeEnumId && condition.fieldName === fieldName && condition.operator === operator)
    if(condition && conditionTypeEnumId === 'ENTCT_ATP_FAC_GROUPS') {
      let facilityGroupIds = condition?.fieldValue.split(",")
        facilityGroupIds = facilityGroupIds.map((id: string) => {
          let group = facilityGroups.value.find((group: any) => group.facilityGroupId === id)
          return group ? group.facilityGroupName : null
        })
        return facilityGroupIds.join(", ")
    } else {
      return condition?.fieldValue?.split(",").join(", ")
    }
  } else {
    const condition = props.rule.ruleConditions.find((condition: any) => condition.conditionTypeEnumId === conditionTypeEnumId)

    if(condition && condition.fieldValue) {
      let facilities = condition?.fieldValue.split(",")
      facilities = facilities.map((id: string) => {
        let facility = configFacilities.value.find((facility: any) => facility.facilityId === id)
        return facility ? facility.facilityName : null
      })
      return facilities.join(", ")
    }
  }
}

async function archiveRule() {
  const alert = await alertController
    .create({
      header: translate('Archive rule'),
      message: translate('Are you sure you want to archive this rule?'),
      buttons: [{
        text: translate('No'),
        role: 'cancel'
      }, {
        text: translate('Yes'),
        handler: async () => {
          emitter.emit("presentLoader");
          const rule = JSON.parse(JSON.stringify(props.rule))
          rule.statusId = "ATP_RULE_ARCHIVED"

          try {
            await RuleService.updateRule(rule, props.rule.ruleId)
            await store.dispatch('rule/archiveRule', { rule })
            showToast(translate("Rule archived successfully."))
            alertController.dismiss()
          } catch(err: any) {
            showToast(translate("Failed to update threhold."))
            logger.error(err);
          }
          emitter.emit("dismissLoader");
        }
      }]
    });
  return alert.present();
}

function getSelectedFacilities() {
  const condition = props.rule.ruleConditions?.find((condition: any) => condition.conditionTypeEnumId === "ENTCT_ATP_FACILITIES")
  return (condition && condition.fieldValue) ? condition.fieldValue.split(",") : []
}

function getSelectedFacilityGroups() {
  const condition = props.rule.ruleConditions?.find((condition: any) => condition.conditionTypeEnumId === "ENTCT_ATP_FAC_GROUPS")
  return (condition && condition.fieldValue) ? condition.fieldValue.split(",") : []
}

async function openSelectConfigFacilitiesModal() {
  const modal = await modalController.create({
    component: SelectConfigFacilitiesModal,
    componentProps: {
      selectedFacilities: getSelectedFacilities(),
      rule: props.rule
    },
  })

  modal.present()
}

async function openUpdateFacilityGroupModal() {
  const modal = await modalController.create({
    component: UpdateFacilityGroupModal,
    componentProps: {
      rule: props.rule
    },
  })

  modal.present()
}

function isRuleConditionAvailable(conditionTypeEnumId: string, fieldName?: string, operator? : string) {
  if(fieldName) return props.rule.ruleConditions?.find((condition: any) => condition.conditionTypeEnumId === conditionTypeEnumId && condition.fieldName === fieldName && condition.operator === operator)?.fieldValue
  else return props.rule.ruleConditions?.find((condition: any) => condition.conditionTypeEnumId === conditionTypeEnumId)?.fieldValue
}

async function openUpdateProductFiltersModal(label: string, facetToSelect: string, searchfield: string) {
  const modal = await modalController.create({
    component: UpdateProductFiltersModal,
    componentProps: {
      label,
      facetToSelect,
      searchfield,
      rule: props.rule
    },
  })

  modal.present()
}

async function updateRulePickup(event: any) {
  event.stopImmediatePropagation();
  const isChecked = !event.target.checked;
  
  emitter.emit("presentLoader");
  try {
    const rule = JSON.parse(JSON.stringify(props.rule))
    rule.ruleActions.map((action: any) => {
      if(action.actionTypeEnumId === "ATP_ALLOW_PICKUP") action.fieldValue = isChecked
    })

    await RuleService.updateRule(rule, props.rule.ruleId)
    showToast(translate("Rule pickup updated successfully."))
    await store.dispatch('rule/updateRuleData', { rule })
    event.target.checked = isChecked
  } catch(err) {
    logger.error(err)
    showToast(translate("Failed to update rule pickup."))
  }
  emitter.emit("dismissLoader");
}

async function updateRuleShipping(event: any) {
  event.stopImmediatePropagation();
  const isChecked = !event.target.checked;

  emitter.emit("presentLoader");
  try {
    const rule = JSON.parse(JSON.stringify(props.rule))
    rule.ruleActions.map((action: any) => {
      if(action.actionTypeEnumId === "ATP_ALLOW_BROKERING") action.fieldValue = isChecked
    })

    await RuleService.updateRule(rule, props.rule.ruleId)
    showToast(translate("Rule shipping updated successfully."))
    await store.dispatch('rule/updateRuleData', { rule })
    event.target.checked = isChecked
  } catch(err) {
    logger.error(err)
    showToast(translate("Failed to update rule brokering."))
  }
  emitter.emit("dismissLoader");
}

async function updateRuleOrder(ruleDir: string) {
  const prevSeq = JSON.parse(JSON.stringify(rules.value));
  const updatedSeq = JSON.parse(JSON.stringify(rules.value));
  let alternateRuleIndex = '' as any;

  if(ruleDir === 'prev') alternateRuleIndex = props.ruleIndex - 1
  else alternateRuleIndex = props.ruleIndex + 1;

  [updatedSeq[props.ruleIndex], updatedSeq[alternateRuleIndex]] = [updatedSeq[alternateRuleIndex], updatedSeq[props.ruleIndex]]

  let diffSeq = findRulesDiff(prevSeq, updatedSeq)

  const updatedSeqenceNum = prevSeq.map((rule: any) => rule.sequenceNum)
  Object.keys(diffSeq).map((key: any) => {
    diffSeq[key].sequenceNum = updatedSeqenceNum[key]
  })

  diffSeq = Object.keys(diffSeq).map((key) => diffSeq[key])

  try {
    diffSeq.map(async (rule: any) => {
      await RuleService.updateRule(rule, rule.ruleId);
    })
    await store.dispatch('rule/updateRules', { rules: updatedSeq })
    showToast(translate("Rules order has been updated successfully."))
  } catch(err: any) {
    logger.error(err);
    showToast(translate("Failed to update rules order."))
  }
}

function findRulesDiff(previousSeq: any, updatedSeq: any) {
  const diffSeq: any = Object.keys(previousSeq).reduce((diff, key) => {
    if (updatedSeq[key].ruleId === previousSeq[key].ruleId) return diff
    return {
      ...diff,
      [key]: updatedSeq[key]
    }
  }, {})
  return diffSeq;
}
</script>

<style scoped>
ion-card-header {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
}
</style>